# 自动引用计数

本页包含内容：

-   自动引用计数的工作机制
-   自动引用计数实践
-   类实例间的强引用环
-   类实例间的强引用环分解
-   闭包的强引用环
-   闭包的强引用环分解

Swift使用自动引用计数(ARC)这一机制来跟踪和管理你的应用程序的内存。通常情况下，Swift的内存管理机制会一直起着作用，你无须自己来考虑内存的管理。ARC会在类的实例不再被使用时，自动释放其占用的内存。

然而，在少数情况下，ARC为了能帮助你管理内存，需要更多的关于你的代码之间关系的信息。本章描述了这些情况，并且为你示范怎样启用ARC来管理你的应用程序的内存。

> 注意: 引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。

## 自动引用计数的工作机制

当你每次创建一个类的新的实例的时候，ARC会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。此外，当实例不再被使用时，ARC释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。

然而，当ARC收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。

为了确保使用中的实例不会被回收，ARC会跟踪和计算每一个类实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为一，ARC都不会回收这个实例。

为了使之成为可能，无论你将类实例赋值给属性，常量或者是变量，属性，常量或者变量，都会对此实例创建强引用。之所以称之为强引用，是因为它会将实例牢牢的保持住，只要强引用还在，实例是不允许被释放的。

## 自动引用计数实战

下面的例子展示了自动引用计数的工作机制。例子以一个简单的Person类开始，并定义了一个叫name的常量属性：

		class Person {
    		let name: String

				init(name: String) {
        		self.name = name
        		println("\(name) is being initialized")
    		}
    		
				deinit {
        		println("\(name) is being deinitialized")
    		}
		}

Person类有一个构造函数，此构造函数为实例的name属性赋值并打印出信息，以表明初始化过程生效。Person类同时也拥有析构函数，同样会在类实例被回收的时候打印出信息。

接下来的代码片段定义了三个类型为Person?的变量，用来按照代码片段中的顺序，为新的Person类实例建立多个引用。由于这些变量是被定义为可选类型(Person?，而不是Person)，它们的值会被自动初始化为nil，目前还不会引用到Person类的实例。

		var reference1: Person?
		var reference2: Person?
		var reference3: Person?

现在你可以创建Person类的新实例，并且将它赋值给三个变量其中的一个：

		reference1 = Person(name: "John Appleseed")
		// prints "John Appleseed is being initialized”

应当注意到当你调用Person类的构造函数的时候，"John Appleseed is being initialized”会被打印出来。由此可以确定构造函数被执行。

由于Person类的新实例被赋值给了reference1变量，所以reference1到Person类的新实例之间建立了一个强引用。正是因为这个强引用，ARC会保证Person实例被保持在内存中不被回收。

如果你将同样的Person类实例也赋值给其他两个变量，该实例又会多出两个强引用：

		reference2 = reference1
		reference3 = reference1

现在这个Person类实例已经有三个强引用了。

(未完待续)
