# 特性

特性提供了关于声明和类型的更多信息。在Swift中有两类特性，应用于声明的以及应用于类型的。例如，`required`属性，当应用于一个类的[待改：designated或convenience]初始化器声明时，表明它的每个子类都必须实现那个初始化器。再比如`noreturn`特性，当应用于函数或方法类型时，表明该函数或方法不会返回到它的调用者。

通过以下方式指定一个特性：符号`@`后面跟特性名，如果包含参数，则把参数带上：

```
@attribute name
@attribute name(attribute arguments)
```

有些声明特性通过接收参数来指定特性的更多信息以及它是如何应用于一个特定的声明的。这些特性的参数写在小括号内，它们的格式由它们所属的特性来定义。

## 声明特性

声明特性只能应用于声明。然而，你也可以将`noreturn`特性应用于函数或方法类型。

`assignment`

对重载了复合赋值运算符的函数应用这个特性。重载了复合赋值运算符的函数必需将它们的初始输入参数标记为`inout`。如何使用`assignment`特性的一个例子，请见：[复合赋值运算符]()。

`class_protocol`

对一个协议应用该特性表明该协议只能被类类型采用[待改：adopted]。

如果你应用`objc`特性到一个协议，`class_protocol`特性就会隐式地应用到该协议，因此无需显式地用`class_protocol`特性标记该协议。

`exported`

对一个导入声明应用该特性，以此来导出已导入的模块，子模块，或当前模块的声明。如果另一个模块导入了当前模块，那么那个模块可以访问当前模块的导出项。

`final`

对一个类或类中的属性，方法，下标成员应用这个特性。如果将它应用于一个类，那么这个类则不能被继承。如果将它应用于类中的属性，方法或下标，则表示在子类中，它们不能被重写。

`lazy`

对类或结构体中的存储型变量属性应用该特性，表示该属性的初始值最多只被计算和存储一次，且发生在第一次访问它时。如何使用`lazy`特性的一个例子，请见：[惰性存储型属性]()。

`noreturn`

对一个函数或方法声明应用该特性，表明该函数或方法的对应类型，`T`，是`@noreturn T`。你可以用这个特性标记函数或方法的类型，这样一来，函数或方法就不会返回到它的调用者中去。

对于一个没有用`noreturn`特性标记的函数或方法，你可以将它重写(override)为用该特性标记的。相反，对于一个已经用`noreturn`特性标记的函数或方法，你则不可以将它重写为没使用该特性标记的。相同的规则试用于当你在一个一致性类型中实现一个协议方法时。

`NSCopying`

对一个类的存储型变量属性应用该特性。该特性将使属性的setter与属性值的一个副本合成，由`copyWithZone`方法返回，而不是属性本身的值。该属性的类型必需符合`NSCopying`协议。

`NSCopying`特性的行为与Objective-C中的`copy`特性相似。

`NSManaged`

对`NSManagedObject`子类中的存储型变量属性应用该特性，表明属性的存储和实现由Core Data在运行时基于相关实体描述动态提供。

`objc`

对任意可以在Objective-C中表示的声明应用该特性，比如，非嵌套类，协议，类和协议中的属性和方法（包含getter和setter），初始化器，析构器，以下下标。`objc`特性告诉编译器该声明可以在Objective-C代码中使用。

如果你将`objc`特性应用于一个类或协议，它也会隐式地应用于那个类或协议的成员。对于标记了`objc`特性的类，编译器会隐式地为它的子类添加`objc`特性。标记了`objc`特性的协议不能继承自没有标记`objc`的协议。

`objc`特性有一个可选的参数，由标记符组成。当你想把`objc`所修饰的实体以一个不同的名字暴露给Objective-C，你就可以使用这个特性参数。你可以使用这个参数来命名类，协议，方法，getters，setters，以及初始化器。下面的例子把`ExampleClass`中`enabled`属性的getter暴露给Objective-C，名字是`isEnabled`，而不是它原来的属性名。

```
@objc
class ExampleClass {
    var enabled: Bool {
    @objc(isEnabled) get {
        // Return the appropriate value
    }
    }
}
```

`optional`
